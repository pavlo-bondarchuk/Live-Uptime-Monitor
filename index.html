<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Uptime Monitor</title>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 18px; background: #0b0f14; color: #e6edf3; }
    .wrap { max-width: 1200px; margin: 0 auto; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .card { background: #111823; border: 1px solid #223044; border-radius: 14px; padding: 14px; }
    .grid { display: grid; gap: 10px; grid-template-columns: 1.2fr 0.6fr 0.6fr 0.6fr 0.8fr; align-items: end; }
    label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    input, select, button, textarea { width: 100%; box-sizing: border-box; border-radius: 10px; border: 1px solid #2b3a52; background: #0d141f; color: #e6edf3; padding: 10px; }
    input[type="number"]{ padding-right: 6px; }
    button { cursor: pointer; border: 1px solid #2b3a52; background: #152235; }
    button:hover { background: #1a2b44; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 180px; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; }
    .actions button { width: auto; padding: 10px 14px; }
    .meta { display: flex; gap: 12px; flex-wrap: wrap; font-size: 12px; opacity: 0.85; margin-top: 10px; }
    .pill { border: 1px solid #2b3a52; border-radius: 999px; padding: 6px 10px; background: #0d141f; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; font-size: 12px; }
    th, td { border-bottom: 1px solid #223044; padding: 8px; vertical-align: top; }
    th { text-align: left; opacity: 0.85; font-weight: 600; }
    tr.bad td { background: rgba(255, 80, 80, 0.08); }
    tr.warn td { background: rgba(255, 190, 80, 0.08); }
    .muted { opacity: 0.7; }
    .small { font-size: 11px; opacity: 0.75; }
    .right { text-align: right; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .sticky { position: sticky; top: 0; background: #111823; }
    .two { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } .two{ grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Live Uptime Monitor</h1>

    <div class="card">
      <div class="grid">
        <div>
          <label>Target URL</label>
          <input id="targetUrl" placeholder="https://example.com/" />
        </div>

        <div>
          <label>Interval (sec)</label>
          <input id="intervalSec" type="number" min="2" value="15" />
        </div>

        <div>
          <label>Timeout (sec)</label>
          <input id="timeoutSec" type="number" min="2" value="10" />
        </div>

        <div>
          <label>Method</label>
          <select id="method">
            <option value="GET">GET</option>
            <option value="HEAD">HEAD</option>
          </select>
        </div>

        <div>
          <label>Proxy</label>
          <select id="proxyMode">
            <option value="direct">Direct (may fail due to CORS)</option>
            <option value="worker">Cloudflare Worker Proxy</option>
          </select>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Worker URL (only if Proxy = Worker)</label>
          <input id="workerUrl" placeholder="https://your-worker.your-subdomain.workers.dev/check" />
          <div class="small muted">The worker endpoint should accept: ?url=... and return JSON.</div>
        </div>
        <div>
          <label>White screen heuristic</label>
          <select id="whiteHeuristic">
            <option value="on">On</option>
            <option value="off">Off</option>
          </select>
          <div class="small muted">Heuristic detects empty/very short HTML or missing &lt;body&gt;/&lt;title&gt; patterns.</div>
        </div>
      </div>

      <div class="actions" style="margin-top:12px;">
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="clearBtn">Clear log</button>
        <button id="exportCsvBtn">Export CSV</button>
        <button id="exportJsonBtn">Export JSON</button>
        <button id="testOnceBtn">Test once</button>
      </div>

      <div class="meta">
        <div class="pill">Status: <span id="statusText" class="mono">idle</span></div>
        <div class="pill">Last check: <span id="lastCheck" class="mono">—</span></div>
        <div class="pill">Fails: <span id="fails" class="mono">0</span></div>
        <div class="pill">Warnings: <span id="warns" class="mono">0</span></div>
        <div class="pill">Total: <span id="total" class="mono">0</span></div>
      </div>
    </div>

    <div class="two" style="margin-top:12px;">
      <div class="card">
        <div class="row">
          <div>
            <label>Filter</label>
            <select id="filter">
              <option value="all">All</option>
              <option value="bad">Bad only</option>
              <option value="warn">Warnings only</option>
              <option value="ok">OK only</option>
            </select>
          </div>
          <div>
            <label>Keep last N</label>
            <input id="keepLast" type="number" min="50" value="800" />
          </div>
          <div>
            <label>Sound on fail</label>
            <select id="soundFail">
              <option value="on">On</option>
              <option value="off">Off</option>
            </select>
          </div>
        </div>
        <div class="small muted" style="margin-top:10px;">
          Tip: If you need real "white screen" detection for WP/PHP fatals, the best signal is server-side (HTTP 500/502/504) or an empty/very small HTML response.
        </div>
      </div>

      <div class="card">
        <label>Notes</label>
        <textarea id="notes" rows="5" placeholder="Optional notes stored locally..."></textarea>
        <div class="small muted">Notes are saved in localStorage.</div>
      </div>
    </div>

    <div class="card" style="margin-top:12px; padding:0;">
      <div style="overflow:auto; border-radius:14px;">
        <table>
          <thead class="sticky">
            <tr>
              <th style="min-width:170px;">Time</th>
              <th style="min-width:80px;">Result</th>
              <th style="min-width:60px;">HTTP</th>
              <th style="min-width:90px;">Latency</th>
              <th>Details</th>
              <th class="right" style="min-width:80px;">Bytes</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
(() => {
  const els = {
    targetUrl: document.getElementById("targetUrl"),
    intervalSec: document.getElementById("intervalSec"),
    timeoutSec: document.getElementById("timeoutSec"),
    method: document.getElementById("method"),
    proxyMode: document.getElementById("proxyMode"),
    workerUrl: document.getElementById("workerUrl"),
    whiteHeuristic: document.getElementById("whiteHeuristic"),
    startBtn: document.getElementById("startBtn"),
    stopBtn: document.getElementById("stopBtn"),
    clearBtn: document.getElementById("clearBtn"),
    exportCsvBtn: document.getElementById("exportCsvBtn"),
    exportJsonBtn: document.getElementById("exportJsonBtn"),
    testOnceBtn: document.getElementById("testOnceBtn"),
    statusText: document.getElementById("statusText"),
    lastCheck: document.getElementById("lastCheck"),
    fails: document.getElementById("fails"),
    warns: document.getElementById("warns"),
    total: document.getElementById("total"),
    tbody: document.getElementById("tbody"),
    filter: document.getElementById("filter"),
    keepLast: document.getElementById("keepLast"),
    soundFail: document.getElementById("soundFail"),
    notes: document.getElementById("notes")
  };

  const STORAGE_KEY = "live_uptime_monitor_v1";
  const NOTES_KEY = "live_uptime_monitor_notes_v1";

  let timer = null;
  let running = false;
  let log = [];

  const nowIsoLocal = () => {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    const tz = -d.getTimezoneOffset();
    const sign = tz >= 0 ? "+" : "-";
    const hh = pad(Math.floor(Math.abs(tz) / 60));
    const mm = pad(Math.abs(tz) % 60);
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())} ${sign}${hh}:${mm}`;
  };

  const save = () => {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(log)); } catch(e) {}
  };

  const load = () => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) log = JSON.parse(raw) || [];
    } catch(e) { log = []; }
    els.notes.value = localStorage.getItem(NOTES_KEY) || "";
  };

  const saveNotes = () => {
    try { localStorage.setItem(NOTES_KEY, els.notes.value || ""); } catch(e) {}
  };

  const clipLog = () => {
    const keep = Math.max(50, parseInt(els.keepLast.value || "800", 10));
    if (log.length > keep) log = log.slice(log.length - keep);
  };

  const beep = () => {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "sine";
      o.frequency.value = 880;
      g.gain.value = 0.06;
      o.connect(g);
      g.connect(ctx.destination);
      o.start();
      setTimeout(() => { o.stop(); ctx.close(); }, 180);
    } catch(e) {}
  };

  const classify = (entry) => {
    if (entry.ok !== true) return "bad";
    if (entry.white === true) return "warn";
    if (entry.http && entry.http >= 400) return "bad";
    if (entry.http && entry.http >= 300) return "warn";
    return "ok";
  };

  const looksWhite = (bodyText, headersObj) => {
    if (els.whiteHeuristic.value !== "on") return false;
    const ct = (headersObj["content-type"] || headersObj["Content-Type"] || "").toLowerCase();
    if (ct && !ct.includes("text/html")) return false;
    const s = (bodyText || "").trim();
    if (!s) return true;
    if (s.length < 250) return true;
    const hasBody = /<body[\s>]/i.test(s);
    const hasTitle = /<title[\s>]/i.test(s);
    if (!hasBody && !hasTitle) return true;
    const onlyTags = s.replace(/<[^>]+>/g, "").trim();
    if (onlyTags.length < 40) return true;
    return false;
  };

  const render = () => {
    const f = els.filter.value;
    const rows = log.slice().reverse().filter((e) => {
      const c = classify(e);
      if (f === "all") return true;
      return c === f;
    });

    els.tbody.innerHTML = rows.map((e) => {
      const c = classify(e);
      const cls = c === "bad" ? "bad" : (c === "warn" ? "warn" : "");
      const res = c.toUpperCase();
      const http = e.http == null ? "—" : String(e.http);
      const lat = e.latencyMs == null ? "—" : `${e.latencyMs} ms`;
      const bytes = e.bytes == null ? "—" : String(e.bytes);
      const detail = [
        e.error ? `Error: ${escapeHtml(e.error)}` : "",
        e.redirected ? "Redirected" : "",
        e.white ? "White screen suspected" : "",
        e.finalUrl ? `Final URL: ${escapeHtml(e.finalUrl)}` : ""
      ].filter(Boolean).join(" · ");
      const hint = e.snippet ? `<div class="small muted mono" style="margin-top:4px; white-space:pre-wrap;">${escapeHtml(e.snippet)}</div>` : "";
      return `
        <tr class="${cls}">
          <td class="mono">${escapeHtml(e.time)}</td>
          <td class="mono">${res}</td>
          <td class="mono">${http}</td>
          <td class="mono">${escapeHtml(lat)}</td>
          <td>${detail || "<span class='muted'>—</span>"}${hint}</td>
          <td class="mono right">${escapeHtml(bytes)}</td>
        </tr>
      `;
    }).join("");

    const bad = log.filter((e) => classify(e) === "bad").length;
    const warn = log.filter((e) => classify(e) === "warn").length;
    els.fails.textContent = String(bad);
    els.warns.textContent = String(warn);
    els.total.textContent = String(log.length);
  };

  const escapeHtml = (s) => String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");

  const normalizeUrl = (u) => {
    const s = (u || "").trim();
    if (!s) return "";
    try {
      const url = new URL(s);
      return url.toString();
    } catch(e) {
      try { return new URL("https://" + s).toString(); } catch(_) {}
    }
    return s;
  };

  const buildWorkerCheckUrl = (workerBase, target, method, timeoutSec) => {
    const base = workerBase.replace(/\/+$/, "");
    const qs = new URLSearchParams({
      url: target,
      method,
      timeout: String(timeoutSec)
    });
    return `${base}?${qs.toString()}`;
  };

  const directCheck = async ({ target, method, timeoutMs }) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    const started = performance.now();
    try {
      const r = await fetch(target, {
        method,
        mode: "cors",
        cache: "no-store",
        redirect: "follow",
        signal: ctrl.signal
      });
      const latencyMs = Math.round(performance.now() - started);
      let text = "";
      if (method !== "HEAD") {
        try { text = await r.text(); } catch(e) { text = ""; }
      }
      const headersObj = {};
      try { r.headers.forEach((v, k) => headersObj[k] = v); } catch(e) {}
      const snippet = text ? text.slice(0, 500) : "";
      const bytes = text ? new TextEncoder().encode(text).length : null;
      const white = method === "HEAD" ? false : looksWhite(text, headersObj);
      return {
        ok: true,
        http: r.status,
        latencyMs,
        bytes,
        redirected: r.redirected,
        finalUrl: r.url,
        white,
        snippet
      };
    } finally {
      clearTimeout(t);
    }
  };

  const workerCheck = async ({ workerBase, target, method, timeoutSec, timeoutMs }) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    const started = performance.now();
    try {
      const checkUrl = buildWorkerCheckUrl(workerBase, target, method, timeoutSec);
      const r = await fetch(checkUrl, {
        method: "GET",
        cache: "no-store",
        signal: ctrl.signal
      });
      const latencyMs = Math.round(performance.now() - started);
      let data = null;
      try { data = await r.json(); } catch(e) { data = null; }
      if (!r.ok || !data) {
        return {
          ok: false,
          http: r.status,
          latencyMs,
          bytes: null,
          redirected: false,
          finalUrl: "",
          white: false,
          snippet: "",
          error: "Worker response is not OK or invalid JSON"
        };
      }
      const white = method === "HEAD" ? false : looksWhite(data.bodyText || "", data.headers || {});
      return {
        ok: true,
        http: data.status ?? null,
        latencyMs: data.timing?.totalMs ?? latencyMs,
        bytes: data.bytes ?? null,
        redirected: !!data.redirected,
        finalUrl: data.finalUrl || "",
        white,
        snippet: (data.bodyText || "").slice(0, 500),
        error: data.error || ""
      };
    } finally {
      clearTimeout(t);
    }
  };

  const doCheck = async () => {
    const target = normalizeUrl(els.targetUrl.value);
    if (!target) return;

    const intervalSec = Math.max(2, parseInt(els.intervalSec.value || "15", 10));
    const timeoutSec = Math.max(2, parseInt(els.timeoutSec.value || "10", 10));
    const timeoutMs = timeoutSec * 1000;

    const method = els.method.value;
    const mode = els.proxyMode.value;

    els.statusText.textContent = "checking...";
    els.lastCheck.textContent = nowIsoLocal();

    const entry = { time: nowIsoLocal(), target, mode, method };

    try {
      let res;
      if (mode === "worker") {
        const workerBase = (els.workerUrl.value || "").trim();
        if (!workerBase) throw new Error("Worker URL is empty");
        res = await workerCheck({ workerBase, target, method, timeoutSec, timeoutMs });
      } else {
        res = await directCheck({ target, method, timeoutMs });
      }

      Object.assign(entry, res);
      if (entry.error) entry.ok = false;

    } catch(e) {
      entry.ok = false;
      entry.http = null;
      entry.latencyMs = null;
      entry.bytes = null;
      entry.redirected = false;
      entry.finalUrl = "";
      entry.white = false;
      entry.snippet = "";
      entry.error = e && e.name === "AbortError" ? "Timeout" : String(e?.message || e || "Unknown error");
    }

    log.push(entry);
    clipLog();
    save();
    render();

    const c = classify(entry);
    els.statusText.textContent = c;
    if (c === "bad" && els.soundFail.value === "on") beep();
  };

  const start = async () => {
    if (running) return;
    const target = normalizeUrl(els.targetUrl.value);
    if (!target) {
      els.statusText.textContent = "missing URL";
      return;
    }
    running = true;
    els.startBtn.disabled = true;
    els.stopBtn.disabled = false;
    els.statusText.textContent = "running";
    await doCheck();
    const intervalMs = Math.max(2, parseInt(els.intervalSec.value || "15", 10)) * 1000;
    timer = setInterval(doCheck, intervalMs);
  };

  const stop = () => {
    running = false;
    els.startBtn.disabled = false;
    els.stopBtn.disabled = true;
    els.statusText.textContent = "stopped";
    if (timer) clearInterval(timer);
    timer = null;
  };

  const clearLog = () => {
    log = [];
    save();
    render();
    els.statusText.textContent = "cleared";
  };

  const downloadText = (filename, content, type) => {
    const blob = new Blob([content], { type: type || "text/plain;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 0);
  };

  const toCsv = (items) => {
    const cols = ["time","target","mode","method","ok","http","latencyMs","bytes","white","redirected","finalUrl","error"];
    const esc = (v) => `"${String(v ?? "").replaceAll('"','""')}"`;
    const lines = [cols.join(",")];
    for (const it of items) lines.push(cols.map((c) => esc(it[c])).join(","));
    return lines.join("\n");
  };

  els.startBtn.addEventListener("click", start);
  els.stopBtn.addEventListener("click", stop);
  els.clearBtn.addEventListener("click", clearLog);
  els.exportCsvBtn.addEventListener("click", () => downloadText("uptime-log.csv", toCsv(log), "text/csv;charset=utf-8"));
  els.exportJsonBtn.addEventListener("click", () => downloadText("uptime-log.json", JSON.stringify(log, null, 2), "application/json;charset=utf-8"));
  els.testOnceBtn.addEventListener("click", doCheck);
  els.filter.addEventListener("change", render);
  els.keepLast.addEventListener("change", () => { clipLog(); save(); render(); });
  els.notes.addEventListener("input", saveNotes);

  load();
  render();
})();
</script>
</body>
</html>
