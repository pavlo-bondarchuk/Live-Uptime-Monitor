<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Live Uptime Monitor</title>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 18px; background: #0b0f14; color: #e6edf3; }
    .wrap { max-width: 1200px; margin: 0 auto; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .card { background: #111823; border: 1px solid #223044; border-radius: 14px; padding: 14px; }
    .grid { display: grid; gap: 10px; grid-template-columns: 1.2fr 0.6fr 0.6fr 0.6fr 0.8fr; align-items: end; }
    label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    input, select, button, textarea { width: 100%; box-sizing: border-box; border-radius: 10px; border: 1px solid #2b3a52; background: #0d141f; color: #e6edf3; padding: 10px; }
    input[type="number"]{ padding-right: 6px; }
    button { cursor: pointer; border: 1px solid #2b3a52; background: #152235; }
    button:hover { background: #1a2b44; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 180px; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; }
    .actions button { width: auto; padding: 10px 14px; }
    .meta { display: flex; gap: 12px; flex-wrap: wrap; font-size: 12px; opacity: 0.85; margin-top: 10px; }
    .pill { border: 1px solid #2b3a52; border-radius: 999px; padding: 6px 10px; background: #0d141f; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; font-size: 12px; }
    th, td { border-bottom: 1px solid #223044; padding: 8px; vertical-align: top; }
    th { text-align: left; opacity: 0.85; font-weight: 600; }
    tr.bad td { background: rgba(255, 80, 80, 0.08); }
    tr.warn td { background: rgba(255, 190, 80, 0.08); }
    .muted { opacity: 0.7; }
    .small { font-size: 11px; opacity: 0.75; }
    .right { text-align: right; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .sticky { position: sticky; top: 0; background: #111823; }
    .two { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } .two{ grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Live Uptime Monitor</h1>

    <div class="card">
      <div class="grid">
        <div>
          <label>Target URL</label>
          <input id="targetUrl" placeholder="https://example.com/" />
        </div>

        <div>
          <label>Interval (sec)</label>
          <input id="intervalSec" type="number" min="2" value="15" />
        </div>

        <div>
          <label>Timeout (sec)</label>
          <input id="timeoutSec" type="number" min="2" value="10" />
        </div>

        <div>
          <label>Method</label>
          <select id="method">
            <option value="GET">GET</option>
            <option value="HEAD">HEAD</option>
          </select>
        </div>

        <div>
          <label>Proxy</label>
          <select id="proxyMode">
            <option value="direct">Direct (may fail due to CORS)</option>
            <option value="worker">Cloudflare Worker Proxy</option>
          </select>
          <div id="corsWarning" class="small" style="margin-top:4px; color:#f85149; display:none;">
            ⚠️ Direct may fail due to CORS; use Worker.
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Worker URL (only if Proxy = Worker)</label>
          <input id="workerUrl" placeholder="https://your-worker.your-subdomain.workers.dev/check" />
          <div class="small muted">The worker endpoint should accept: ?url=... and return JSON.</div>
        </div>
        <div>
          <label>White screen heuristic</label>
          <select id="whiteHeuristic">
            <option value="on">On</option>
            <option value="off">Off</option>
          </select>
          <div class="small muted">Heuristic detects empty/very short HTML or missing &lt;body&gt;/&lt;title&gt; patterns.</div>
        </div>
      </div>

      <div class="actions" style="margin-top:12px;">
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="clearBtn">Clear log</button>
        <button id="exportCsvBtn">Export CSV</button>
        <button id="exportJsonBtn">Export JSON</button>
        <button id="testOnceBtn">Test once</button>
        <button id="resetBtn">Reset settings</button>
      </div>

      <div class="meta">
        <div class="pill">
          Status: <span id="statusText" class="mono">idle</span>
          <span id="spinner" style="display:none; margin-left:6px;">⏳</span>
        </div>
        <div class="pill">Next check in: <span id="countdown" class="mono">—</span></div>
        <div class="pill">Last check: <span id="lastCheck" class="mono">—</span></div>
        <div class="pill" style="min-width:300px;">Last request: <span id="lastRequest" class="mono">—</span></div>
        <div class="pill">Fails: <span id="fails" class="mono">0</span></div>
        <div class="pill">Warnings: <span id="warns" class="mono">0</span></div>
        <div class="pill">Total: <span id="total" class="mono">0</span></div>
      </div>
    </div>

    <div class="two" style="margin-top:12px;">
      <div class="card">
        <div class="row">
          <div>
            <label>Filter</label>
            <select id="filter">
              <option value="all">All</option>
              <option value="bad">Bad only</option>
              <option value="warn">Warnings only</option>
              <option value="ok">OK only</option>
            </select>
          </div>
          <div>
            <label>Keep last N</label>
            <input id="keepLast" type="number" min="50" value="800" />
          </div>
          <div>
            <label>Sound on fail</label>
            <select id="soundFail">
              <option value="on">On</option>
              <option value="off">Off</option>
            </select>
          </div>
        </div>
        <div class="small muted" style="margin-top:10px;">
          Tip: If you need real "white screen" detection for WP/PHP fatals, the best signal is server-side (HTTP 500/502/504) or an empty/very small HTML response.
        </div>
      </div>

      <div class="card">
        <label>Notes</label>
        <textarea id="notes" rows="5" placeholder="Optional notes stored locally..."></textarea>
        <div class="small muted">Notes are saved in localStorage.</div>
      </div>
    </div>

    <div class="card" style="margin-top:12px; padding:0;">
      <div style="overflow:auto; border-radius:14px;">
        <table>
          <thead class="sticky">
            <tr>
              <th style="min-width:170px;">Time</th>
              <th style="min-width:80px;">Result</th>
              <th style="min-width:60px;">HTTP</th>
              <th style="min-width:90px;">Latency</th>
              <th>Details</th>
              <th class="right" style="min-width:80px;">Bytes</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
(() => {
  const els = {
    targetUrl: document.getElementById("targetUrl"),
    intervalSec: document.getElementById("intervalSec"),
    timeoutSec: document.getElementById("timeoutSec"),
    method: document.getElementById("method"),
    proxyMode: document.getElementById("proxyMode"),
    workerUrl: document.getElementById("workerUrl"),
    whiteHeuristic: document.getElementById("whiteHeuristic"),
    startBtn: document.getElementById("startBtn"),
    stopBtn: document.getElementById("stopBtn"),
    clearBtn: document.getElementById("clearBtn"),
    exportCsvBtn: document.getElementById("exportCsvBtn"),
    exportJsonBtn: document.getElementById("exportJsonBtn"),
    testOnceBtn: document.getElementById("testOnceBtn"),
    statusText: document.getElementById("statusText"),
    lastCheck: document.getElementById("lastCheck"),
    fails: document.getElementById("fails"),
    warns: document.getElementById("warns"),
    total: document.getElementById("total"),
    tbody: document.getElementById("tbody"),
    filter: document.getElementById("filter"),
    keepLast: document.getElementById("keepLast"),
    soundFail: document.getElementById("soundFail"),
    notes: document.getElementById("notes")
  };

  const STORAGE_KEY = "live_uptime_monitor_v1";
  const NOTES_KEY = "live_uptime_monitor_notes_v1";
  const SETTINGS_KEY = "liveUptimeMonitor.settings.v1";

  let timer = null;
  let running = false;
  let log = [];
  let state = "idle";
  let nextCheckTime = null;
  let countdownInterval = null;
  let lastRequestInfo = null;

  const nowIsoLocal = () => {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    const tz = -d.getTimezoneOffset();
    const sign = tz >= 0 ? "+" : "-";
    const hh = pad(Math.floor(Math.abs(tz) / 60));
    const mm = pad(Math.abs(tz) % 60);
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())} ${sign}${hh}:${mm}`;
  };

  const save = () => {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(log)); } catch(e) {}
  };

  const load = () => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) log = JSON.parse(raw) || [];
    } catch(e) { log = []; }
    els.notes.value = localStorage.getItem(NOTES_KEY) || "";
  };

  const saveNotes = () => {
    try { localStorage.setItem(NOTES_KEY, els.notes.value || ""); } catch(e) {}
  };

  const saveSettings = () => {
    try {
      const settings = {
        targetUrl: els.targetUrl.value,
        intervalSec: els.intervalSec.value,
        timeoutSec: els.timeoutSec.value,
        method: els.method.value,
        proxyMode: els.proxyMode.value,
        workerUrl: els.workerUrl.value,
        whiteHeuristic: els.whiteHeuristic.value,
        keepLast: els.keepLast.value,
        soundFail: els.soundFail.value,
        filter: els.filter.value
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    } catch(e) {}
  };

  const loadSettings = () => {
    try {
      const raw = localStorage.getItem(SETTINGS_KEY);
      if (raw) {
        const settings = JSON.parse(raw);
        if (settings.targetUrl !== undefined) els.targetUrl.value = settings.targetUrl;
        if (settings.intervalSec !== undefined) els.intervalSec.value = settings.intervalSec;
        if (settings.timeoutSec !== undefined) els.timeoutSec.value = settings.timeoutSec;
        if (settings.method !== undefined) els.method.value = settings.method;
        if (settings.proxyMode !== undefined) els.proxyMode.value = settings.proxyMode;
        if (settings.workerUrl !== undefined) els.workerUrl.value = settings.workerUrl;
        if (settings.whiteHeuristic !== undefined) els.whiteHeuristic.value = settings.whiteHeuristic;
        if (settings.keepLast !== undefined) els.keepLast.value = settings.keepLast;
        if (settings.soundFail !== undefined) els.soundFail.value = settings.soundFail;
        if (settings.filter !== undefined) els.filter.value = settings.filter;
      }
    } catch(e) {}
  };

  const resetSettings = () => {
    try {
      localStorage.removeItem(SETTINGS_KEY);
      els.targetUrl.value = "";
      els.intervalSec.value = "15";
      els.timeoutSec.value = "10";
      els.method.value = "GET";
      els.proxyMode.value = "direct";
      els.workerUrl.value = "";
      els.whiteHeuristic.value = "on";
      els.keepLast.value = "800";
      els.soundFail.value = "on";
      els.filter.value = "all";
    } catch(e) {}
  };

  const clipLog = () => {
    const keep = Math.max(50, parseInt(els.keepLast.value || "800", 10));
    if (log.length > keep) log = log.slice(log.length - keep);
  };

  const beep = () => {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "sine";
      o.frequency.value = 880;
      g.gain.value = 0.06;
      o.connect(g);
      g.connect(ctx.destination);
      o.start();
      setTimeout(() => { o.stop(); ctx.close(); }, 180);
    } catch(e) {}
  };

  const classify = (entry) => {
    if (entry.ok !== true) return "bad";
    if (entry.white === true) return "warn";
    if (entry.http && entry.http >= 400) return "bad";
    if (entry.http && entry.http >= 300) return "warn";
    return "ok";
  };

  const classifyReason = (entry) => {
    if (entry.white === true) return "WHITE_SCREEN";
    if (entry.http && entry.http >= 400) return "HTTP_ERROR";
    if (entry.http && entry.http >= 300 && entry.http < 400) return "HTTP_REDIRECT";
    if (entry.error) {
      const errMsg = String(entry.error).toLowerCase();
      if (errMsg.includes("timeout") || errMsg.includes("aborted")) return "TIMEOUT";
      if (entry.mode === "direct" && (errMsg.includes("fetch") || errMsg.includes("cors") || errMsg.includes("failed"))) {
        try {
          const targetOrigin = new URL(entry.target).origin;
          const currentOrigin = window.location.origin;
          if (targetOrigin !== currentOrigin) return "CORS_BLOCKED";
        } catch(e) {}
      }
      return "NETWORK_ERROR";
    }
    return "";
  };

  const looksWhite = (bodyText, headersObj) => {
    if (els.whiteHeuristic.value !== "on") return false;
    const ct = (headersObj["content-type"] || headersObj["Content-Type"] || "").toLowerCase();
    if (ct && !ct.includes("text/html")) return false;
    const s = (bodyText || "").trim();
    if (!s) return true;
    if (s.length < 250) return true;
    const hasBody = /<body[\s>]/i.test(s);
    const hasTitle = /<title[\s>]/i.test(s);
    if (!hasBody && !hasTitle) return true;
    const onlyTags = s.replace(/<[^>]+>/g, "").trim();
    if (onlyTags.length < 40) return true;
    return false;
  };

  const render = () => {
    const f = els.filter.value;
    const rows = log.slice().reverse().filter((e) => {
      const c = classify(e);
      if (f === "all") return true;
      return c === f;
    });

    els.tbody.innerHTML = rows.map((e) => {
      const c = classify(e);
      const reason = e.reason || classifyReason(e);
      const cls = c === "bad" ? "bad" : (c === "warn" ? "warn" : "");
      const res = c.toUpperCase();
      const http = e.http == null ? "—" : String(e.http);
      const lat = e.latencyMs == null ? "—" : `${e.latencyMs} ms`;
      const bytes = e.bytes == null ? "—" : String(e.bytes);
      const detailParts = [
        reason ? `Reason: ${escapeHtml(reason)}` : "",
        e.error ? `Error: ${escapeHtml(e.error)}` : "",
        e.redirected ? "Redirected" : "",
        e.white ? "White screen suspected" : "",
        e.finalUrl ? `Final URL: ${escapeHtml(e.finalUrl)}` : ""
      ].filter(Boolean);
      const detail = detailParts.join(" · ");
      const hint = e.snippet ? `<div class="small muted mono" style="margin-top:4px; white-space:pre-wrap;">${escapeHtml(e.snippet)}</div>` : "";
      return `
        <tr class="${cls}">
          <td class="mono">${escapeHtml(e.time)}</td>
          <td class="mono">${res}</td>
          <td class="mono">${http}</td>
          <td class="mono">${escapeHtml(lat)}</td>
          <td>${detail || "<span class='muted'>—</span>"}${hint}</td>
          <td class="mono right">${escapeHtml(bytes)}</td>
        </tr>
      `;
    }).join("");

    const bad = log.filter((e) => classify(e) === "bad").length;
    const warn = log.filter((e) => classify(e) === "warn").length;
    els.fails.textContent = String(bad);
    els.warns.textContent = String(warn);
    els.total.textContent = String(log.length);
  };

  const escapeHtml = (s) => String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");

  const normalizeUrl = (u) => {
    const s = (u || "").trim();
    if (!s) return "";
    try {
      const url = new URL(s);
      return url.toString();
    } catch(e) {
      try { return new URL("https://" + s).toString(); } catch(_) {}
    }
    return s;
  };

  const buildWorkerCheckUrl = (workerBase, target, method, timeoutSec) => {
    const base = workerBase.replace(/\/+$/, "");
    const qs = new URLSearchParams({
      url: target,
      method,
      timeout: String(timeoutSec)
    });
    return `${base}?${qs.toString()}`;
  };

  const directCheck = async ({ target, method, timeoutMs }) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    const started = performance.now();
    try {
      const r = await fetch(target, {
        method,
        mode: "cors",
        cache: "no-store",
        redirect: "follow",
        signal: ctrl.signal
      });
      const latencyMs = Math.round(performance.now() - started);
      let text = "";
      if (method !== "HEAD") {
        try { text = await r.text(); } catch(e) { text = ""; }
      }
      const headersObj = {};
      try { r.headers.forEach((v, k) => headersObj[k] = v); } catch(e) {}
      const snippet = text ? text.slice(0, 500) : "";
      const bytes = text ? new TextEncoder().encode(text).length : null;
      const white = method === "HEAD" ? false : looksWhite(text, headersObj);
      return {
        ok: true,
        http: r.status,
        latencyMs,
        bytes,
        redirected: r.redirected,
        finalUrl: r.url,
        white,
        snippet
      };
    } finally {
      clearTimeout(t);
    }
  };

  const workerCheck = async ({ workerBase, target, method, timeoutSec, timeoutMs }) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    const started = performance.now();
    try {
      const checkUrl = buildWorkerCheckUrl(workerBase, target, method, timeoutSec);
      const r = await fetch(checkUrl, {
        method: "GET",
        cache: "no-store",
        signal: ctrl.signal
      });
      const latencyMs = Math.round(performance.now() - started);
      let data = null;
      try { data = await r.json(); } catch(e) { data = null; }
      
      // Worker returns JSON even for errors (status 502/504)
      // Check if we got valid JSON data
      if (!data) {
        return {
          ok: false,
          http: r.status,
          latencyMs,
          bytes: null,
          redirected: false,
          finalUrl: "",
          white: false,
          snippet: "",
          error: "Worker response is invalid JSON"
        };
      }
      
      // If data has an error field, treat it as a failed check
      if (data.error) {
        return {
          ok: false,
          http: data.status ?? null,
          latencyMs: data.timing?.totalMs ?? latencyMs,
          bytes: data.bytes ?? null,
          redirected: !!data.redirected,
          finalUrl: data.finalUrl || "",
          white: false,
          snippet: "",
          error: data.error
        };
      }
      
      const white = method === "HEAD" ? false : looksWhite(data.bodyText || "", data.headers || {});
      return {
        ok: true,
        http: data.status ?? null,
        latencyMs: data.timing?.totalMs ?? latencyMs,
        bytes: data.bytes ?? null,
        redirected: !!data.redirected,
        finalUrl: data.finalUrl || "",
        white,
        snippet: (data.bodyText || "").slice(0, 500),
        error: data.error || ""
      };
    } finally {
      clearTimeout(t);
    }
  };

  const doCheck = async () => {
    const target = normalizeUrl(els.targetUrl.value);
    if (!target) return;

    const intervalSec = Math.max(2, parseInt(els.intervalSec.value || "15", 10));
    const timeoutSec = Math.max(2, parseInt(els.timeoutSec.value || "10", 10));
    const timeoutMs = timeoutSec * 1000;

    const method = els.method.value;
    const mode = els.proxyMode.value;

    els.statusText.textContent = "checking...";
    els.lastCheck.textContent = nowIsoLocal();
    updateSpinner(true);

    const entry = { time: nowIsoLocal(), target, mode, method };
    const checkStart = performance.now();

    try {
      let res;
      if (mode === "worker") {
        const workerBase = (els.workerUrl.value || "").trim();
        if (!workerBase) throw new Error("Worker URL is empty");
        res = await workerCheck({ workerBase, target, method, timeoutSec, timeoutMs });
      } else {
        res = await directCheck({ target, method, timeoutMs });
      }

      Object.assign(entry, res);
      if (entry.error) entry.ok = false;

    } catch(e) {
      entry.ok = false;
      entry.http = null;
      entry.latencyMs = null;
      entry.bytes = null;
      entry.redirected = false;
      entry.finalUrl = "";
      entry.white = false;
      entry.snippet = "";
      entry.error = e && e.name === "AbortError" ? "Timeout" : String(e?.message || e || "Unknown error");
    }

    entry.reason = classifyReason(entry);
    const checkEnd = performance.now();
    lastRequestInfo = {
      time: entry.time,
      duration: entry.latencyMs || Math.round(checkEnd - checkStart),
      result: classify(entry).toUpperCase()
    };

    log.push(entry);
    clipLog();
    save();
    render();

    const c = classify(entry);
    updateStatus(state);
    updateSpinner(false);
    if (c === "bad" && els.soundFail.value === "on") beep();
  };

  const start = async () => {
    if (running) return;
    const target = normalizeUrl(els.targetUrl.value);
    if (!target) {
      setState("error");
      updateStatus("error");
      return;
    }
    running = true;
    setState("running");
    els.startBtn.disabled = true;
    els.stopBtn.disabled = false;
    updateStatus("running");
    startCountdown();
    await doCheck();
    const intervalMs = Math.max(2, parseInt(els.intervalSec.value || "15", 10)) * 1000;
    timer = setInterval(() => {
      doCheck();
      startCountdown();
    }, intervalMs);
  };

  const stop = () => {
    running = false;
    setState("stopped");
    els.startBtn.disabled = false;
    els.stopBtn.disabled = true;
    updateStatus("stopped");
    stopCountdown();
    if (timer) clearInterval(timer);
    timer = null;
  };

  const setState = (newState) => {
    state = newState;
  };

  const updateStatus = (currentState) => {
    const statusMap = {
      idle: "idle",
      running: "running",
      stopped: "stopped",
      error: "error"
    };
    els.statusText.textContent = statusMap[currentState] || currentState;
  };

  const updateSpinner = (show) => {
    const spinnerEl = document.getElementById("spinner");
    if (spinnerEl) {
      spinnerEl.style.display = show ? "inline" : "none";
    }
  };

  const startCountdown = () => {
    stopCountdown();
    const intervalSec = Math.max(2, parseInt(els.intervalSec.value || "15", 10));
    nextCheckTime = Date.now() + intervalSec * 1000;
    updateCountdown();
    countdownInterval = setInterval(updateCountdown, 500);
  };

  const stopCountdown = () => {
    if (countdownInterval) {
      clearInterval(countdownInterval);
      countdownInterval = null;
    }
    nextCheckTime = null;
    updateCountdown();
  };

  const updateCountdown = () => {
    const countdownEl = document.getElementById("countdown");
    const lastReqEl = document.getElementById("lastRequest");
    if (countdownEl) {
      if (nextCheckTime && state === "running") {
        const remaining = Math.max(0, nextCheckTime - Date.now());
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        countdownEl.textContent = `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
      } else {
        countdownEl.textContent = "—";
      }
    }
    if (lastReqEl && lastRequestInfo) {
      lastReqEl.textContent = `${lastRequestInfo.time} / ${lastRequestInfo.duration} ms / ${lastRequestInfo.result}`;
    }
  };

  const checkCorsWarning = () => {
    const corsWarningEl = document.getElementById("corsWarning");
    if (!corsWarningEl) return;
    const mode = els.proxyMode.value;
    const target = els.targetUrl.value.trim();
    if (mode === "direct" && target) {
      try {
        const targetOrigin = new URL(normalizeUrl(target)).origin;
        const currentOrigin = window.location.origin;
        if (targetOrigin !== currentOrigin) {
          corsWarningEl.style.display = "block";
          return;
        }
      } catch(e) {}
    }
    corsWarningEl.style.display = "none";
  };

  const clearLog = () => {
    log = [];
    save();
    render();
    setState("idle");
    updateStatus("idle");
  };

  const testOnce = async () => {
    const prevState = state;
    await doCheck();
    if (prevState === "idle") {
      setState("idle");
      updateStatus("idle");
    }
  };

  const downloadText = (filename, content, type) => {
    const blob = new Blob([content], { type: type || "text/plain;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 0);
  };

  const toCsv = (items) => {
    const cols = ["time","target","mode","method","ok","http","latencyMs","bytes","white","redirected","finalUrl","error","reason"];
    const esc = (v) => `"${String(v ?? "").replaceAll('"','""')}"`;
    const lines = [cols.join(",")];
    for (const it of items) {
      const reason = it.reason || classifyReason(it);
      const row = cols.map((c) => c === "reason" ? esc(reason) : esc(it[c]));
      lines.push(row.join(","));
    }
    return lines.join("\n");
  };

  els.startBtn.addEventListener("click", start);
  els.stopBtn.addEventListener("click", stop);
  els.clearBtn.addEventListener("click", clearLog);
  els.exportCsvBtn.addEventListener("click", () => downloadText("uptime-log.csv", toCsv(log), "text/csv;charset=utf-8"));
  els.exportJsonBtn.addEventListener("click", () => {
    const exportData = log.map(e => ({ ...e, reason: e.reason || classifyReason(e) }));
    downloadText("uptime-log.json", JSON.stringify(exportData, null, 2), "application/json;charset=utf-8");
  });
  els.testOnceBtn.addEventListener("click", testOnce);
  els.filter.addEventListener("change", () => { saveSettings(); render(); });
  els.keepLast.addEventListener("change", () => { clipLog(); save(); render(); saveSettings(); });
  els.notes.addEventListener("input", saveNotes);

  els.targetUrl.addEventListener("input", () => { saveSettings(); checkCorsWarning(); });
  els.intervalSec.addEventListener("input", saveSettings);
  els.timeoutSec.addEventListener("input", saveSettings);
  els.method.addEventListener("change", saveSettings);
  els.proxyMode.addEventListener("change", () => { saveSettings(); checkCorsWarning(); });
  els.workerUrl.addEventListener("input", saveSettings);
  els.whiteHeuristic.addEventListener("change", saveSettings);
  els.soundFail.addEventListener("change", saveSettings);

  const resetBtn = document.getElementById("resetBtn");
  if (resetBtn) {
    resetBtn.addEventListener("click", () => {
      if (confirm("Reset all settings to defaults?")) {
        resetSettings();
        checkCorsWarning();
      }
    });
  }

  loadSettings();
  load();
  render();
  updateStatus(state);
  checkCorsWarning();
  updateCountdown();
})();
</script>
</body>
</html>
